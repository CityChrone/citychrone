{
  "_args": [
    [
      {
        "raw": "react-komposer@1.13.1",
        "scope": null,
        "escapedName": "react-komposer",
        "name": "react-komposer",
        "rawSpec": "1.13.1",
        "spec": "1.13.1",
        "type": "version"
      },
      "/Users/charlie/Desktop/ok_grow/analytics/analytics/examples/react-router"
    ]
  ],
  "_from": "react-komposer@1.13.1",
  "_id": "react-komposer@1.13.1",
  "_inCache": true,
  "_location": "/react-komposer",
  "_nodeVersion": "4.4.7",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/react-komposer-1.13.1.tgz_1468096379264_0.4422414966393262"
  },
  "_npmUser": {
    "name": "arunoda",
    "email": "arunoda.susiripala@gmail.com"
  },
  "_npmVersion": "3.10.3",
  "_phantomChildren": {
    "lodash.keys": "3.1.2"
  },
  "_requested": {
    "raw": "react-komposer@1.13.1",
    "scope": null,
    "escapedName": "react-komposer",
    "name": "react-komposer",
    "rawSpec": "1.13.1",
    "spec": "1.13.1",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/react-komposer/-/react-komposer-1.13.1.tgz",
  "_shasum": "4b8ac4bcc71323bd7413dcab95c831197f50eed0",
  "_shrinkwrap": null,
  "_spec": "react-komposer@1.13.1",
  "_where": "/Users/charlie/Desktop/ok_grow/analytics/analytics/examples/react-router",
  "bugs": {
    "url": "https://github.com/kadirahq/react-komposer/issues"
  },
  "dependencies": {
    "babel-runtime": "6.x.x",
    "hoist-non-react-statics": "1.x.x",
    "invariant": "2.x.x",
    "mobx": "^2.3.4",
    "shallowequal": "0.2.x"
  },
  "description": "Compose React containers and feed data into components.",
  "devDependencies": {
    "babel-cli": "6.x.x",
    "babel-core": "6.x.x",
    "babel-eslint": "4.x.x",
    "babel-plugin-transform-runtime": "6.x.x",
    "babel-polyfill": "6.x.x",
    "babel-preset-es2015": "6.x.x",
    "babel-preset-react": "6.x.x",
    "babel-preset-stage-2": "6.x.x",
    "browserify": "12.x.x",
    "chai": "3.x.x",
    "enzyme": "^2.2.0",
    "eslint": "1.7.x",
    "eslint-plugin-babel": "2.x.x",
    "eslint-plugin-react": "3.x.x",
    "exposify": "0.5.x",
    "jsdom": "^9.2.1",
    "mocha": "2.x.x",
    "nodemon": "1.7.x",
    "react": "^15.0.0",
    "react-addons-test-utils": "^15.0.0",
    "react-dom": "^15.0.0",
    "rx": "4.x.x",
    "uglifyify": "3.x.x"
  },
  "directories": {},
  "dist": {
    "shasum": "4b8ac4bcc71323bd7413dcab95c831197f50eed0",
    "tarball": "https://registry.npmjs.org/react-komposer/-/react-komposer-1.13.1.tgz"
  },
  "gitHead": "464be7b3c24e959ec18880bf1c3484e3a6edfe7f",
  "homepage": "https://github.com/kadirahq/react-komposer#readme",
  "license": "MIT",
  "maintainers": [
    {
      "name": "arunoda",
      "email": "arunoda.susiripala@gmail.com"
    }
  ],
  "name": "react-komposer",
  "optionalDependencies": {},
  "options": {
    "mocha": "--require scripts/mocha_runner lib/**/__tests__/**/*.js"
  },
  "peerDependencies": {
    "react": "^0.14.3 || ^15.0.0"
  },
  "react-native": "./dist/index.js",
  "readme": "# react-komposer\n\nLet's compose React containers and feed data into components. <br>\n(supports ReactNative as well)\n\n## TOC\n\n* [Why](#why)\n* [Installation](#installation)\n* [Basic Usage](#basic-usage)\n* [API](#api)\n* [Using with XXX](#using-with-xxx)\n    - [Using with Promises](#using-with-promises)\n    - [Using with Meteor](#using-with-meteor)\n    - [Using with Rx.js Observables](#using-with-rxjs-observables)\n    - [Using with Redux](#using-with-redux)\n* [Extending](#extending)\n* [Stubbing](#stubbing)\n* [Caveats](#caveats)\n\n## Why?\n\nLately, in React we try to avoid the use of component state as much as possible and use props to handle the passing of data and actions.\nWe call these stateless components **Dumb Components** or **UI Components.**\n\nThere is another component layer on-top of these **Dumb Components** which handles the **data fetching** logic. We call these components **Containers**. Containers usually do things like:\n\n* Request for data (invoke a subscription or just fetch it).\n* Show a loading screen while the data is fetching.\n* Once data arrives, pass it to the UI Component.\n* If there is an error, show it to the user.\n* It may need to re-fetch or re-subscribe when props change.\n* It needs to cleanup resources (like subscriptions) when the container is unmounting.\n\nIf you want to do these yourself, you have to do a lot of **repetitive tasks**. This commonly leads to **human errors**.\n\n**Meet React Komposer**\n\nThat's what we are going to fix with this project. You simply tell it how to get data and clean up resources, then it'll\ndo the hard work for you. This is a universal project and works with **any kind of data source**, whether it's based on\nPromises, Rx.JS observables, a Redux store or even Meteor's Tracker.\n\n## Installation\n\n```\nnpm i --save react-komposer\n```\n\n## Basic Usage\n\nLet's say we need to build a clock. First let's create a UI Component to show the time.\n\n```js\nconst Time = ({time}) => (<div>Time is: {time}</div>);\n```\n\nNow let's define how to fetch data for this:\n\n```js\nconst onPropsChange = (props, onData) => {\n  const handle = setInterval(() => {\n    const time = (new Date()).toString();\n    onData(null, {time});\n  }, 1000);\n\n  const cleanup = () => clearInterval(handle);\n  return cleanup;\n};\n```\n\nIn the above function, we get new data every second and send it via the `onData` callback. Additionally, we return a cleanup function from the function to cleanup its resources.\n\nOkay. Now it's time to create the clock Container, wrapped around our Time UI Component, using our `onPropsChange` function:\n\n```js\nimport { compose } from 'react-komposer';\nconst Clock = compose(onPropsChange)(Time);\n```\n\nThat's it. Now render the clock to the DOM.\n\n```js\nimport ReactDOM from 'react-dom';\nReactDOM.render(<Clock />, document.body);\n```\n\nSee this live: <https://jsfiddle.net/arunoda/jxse2yw8>\n\n### Additional Benefits\n\nOther than the main benefits, now it's super easy to test our UI code. We can easily do it via a set of unit tests.\n\n* For the UI Components, simply test the plain React component. In this case, `Time` (you can use [enzyme](https://github.com/airbnb/enzyme)).\n* Then test `onPropsChange` for different scenarios.\n\n## API\n\nYou can customize the higher order component created by `compose` in few ways. Let's discuss.\n\n### Handling Errors\n\nRather than showing the data, sometimes you need to deal with errors. Here's how to use `compose` for that:\n\n```js\nconst onPropsChange = (props, onData) => {\n  // oops some error.\n  onData(new Error('Oops'));\n};\n```\n\nThe error will be rendered to the screen (in place of where the component is rendered).\nYou must provide a [JavaScript Error object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Error).\n\nYou can clear it by passing some data again like this:\n\n```js\nconst onPropsChange = (props, onData) => {\n  // oops some error.\n  onData(new Error('Oops'));\n\n  setTimeout(() => {\n    onData(null, {time: Date.now()});\n  }, 5000);\n};\n```\n\n### Detect props changes\n\nSometimes you can use the props to customize our data fetching logic. Here's how to do it:\n\n```js\nconst onPropsChange = (props, onData) => {\n  const handle = setInterval(() => {\n    const time = (props.timestamp)? Date.now() : (new Date()).toString();\n    onData(null, {time});\n  }, 1000);\n\n  const cleanup = () => clearInterval(handle);\n  return cleanup;\n};\n```\n\nHere we are asking to make the Clock to display timestamp instead of the Date string. See:\n\n```js\nReactDOM.render((\n  <div>\n    <Clock timestamp={true}/>\n    <Clock />\n  </div>\n), document.body);\n```\n\nSee this live: <https://jsfiddle.net/arunoda/7qy1mxc7/>\n\n### Change the Loading Component\n\n```js\nconst MyLoading = () => (<div>Hmm...</div>);\nconst Clock = compose(onPropsChange, MyLoading)(Time);\n```\n\n> This custom loading component receives all the props passed to the UI Component as well.\n> So, based on those props, you can change the behaviour of the loading component also.\n\n### Change the Error Component\n\n```js\nconst MyError = ({error}) => (<div>Error: {error.message}</div>);\nconst Clock = compose(onPropsChange, null, MyError)(Time);\n```\n\n### Compose Multiple Containers\n\nSometimes we need to compose multiple containers at once, in order to use different data sources. Checkout the following examples:\n\n```js\nconst Clock = composeWithObservable(composerFn1)(Time);\nconst MeteorClock = composeWithTracker(composerFn2)(Clock);\n\nexport default MeteorClock;\n```\n\nFor the above case, we've a utility called `composeAll` to make our life easier. To use it:\n\n```js\nexport default composeAll(\n  composeWithObservable(composerFn1),\n  composeWithTracker(composerFn2)\n)(Time)\n```\n\n### Pure Containers\n\n`react-komposer` checks the purity of payload, error and props, avoiding unnecessary render function calls. That means\nwe've implemented the `shouldComponentUpdate` lifecycle method, which follows something similar to React's [shallowCompare](https://facebook.github.io/react/docs/shallow-compare.html).\n\nIf you need to turn off this functionality, you can do it like this:\n\n```js\n// You can use `composeWithPromise` or any other compose APIs\n// instead of `compose`.\nconst Clock = compose(onPropsChange, null, null, {pure: false})(Time);\n```\n\n### Ref to base component\n\nIn some situations, you need to get a ref to the base component that you pass to `react-komposer`. You can enable a `ref` with the `withRef` option:\n\n```js\n// You can use `composeWithPromise` or any other compose APIs\n// instead of `compose`.\nconst Clock = compose(onPropsChange, null, null, {withRef: true})(Time);\n```\n\nThe base component will then be accessible with `getWrappedInstance()`. <br/>\nCheckout this [test case](https://github.com/kadirahq/react-komposer/blob/master/lib/__tests__/compose.js#L90) for a proper example.\n\n### Change Default Components\n\nIt is possible to change default error and loading components globally, so you don't need to set default components in every composer call.\n\nHere's how do it:\n\n```js\nimport {\n  setDefaultErrorComponent,\n  setDefaultLoadingComponent,\n} from 'react-komposer';\n\nconst ErrorComponent = () => (<div>My Error</div>);\nconst LoadingComponent = () => (<div>My Loading</div>);\n\nsetDefaultErrorComponent(ErrorComponent);\nsetDefaultLoadingComponent(LoadingComponent);\n```\n\n> This is very important if you are using this in a React Native app,\n> as this project has no default components for React Native.\n> So you can set default components, as shown above, at the very beginning.\n\n## Using with XXX\n\n### Using with Promises\n\nFor use with Promise-based data sources, you can use `composeWithPromise` instead of `compose`.\n\n```js\nimport {composeWithPromise} from 'react-komposer'\n\n// Create a component to display Time\nconst Time = ({time}) => (<div>{time}</div>);\n\n// Assume this get's the time from the Server\nconst getServerTime = () => {\n  return new Promise((resolve) => {\n    const time = new Date().toString();\n    setTimeout(() => resolve({time}), 2000);\n  });\n};\n\n// Create the composer function and tell how to fetch data\nconst composerFunction = (props) => {\n  return getServerTime();\n};\n\n// Compose the container\nconst Clock = composeWithPromise(composerFunction)(Time, Loading);\n\n// Render the container\nReactDOM.render(<Clock />, document.getElementById('react-root'));\n```\n\nSee this live: <https://jsfiddle.net/arunoda/8wgeLexy/>\n\n### Using with Meteor\n\nFor use with Meteor, you need to use `composeWithTracker` instead of `compose`, from where you can watch any Reactive data.\n\n```js\nimport {composeWithTracker} from 'react-komposer';\nimport PostList from '../components/post_list.jsx';\n\nfunction composer(props, onData) {\n  if (Meteor.subscribe('posts').ready()) {\n    const posts = Posts.find({}, {sort: {_id: 1}}).fetch();\n    onData(null, {posts});\n  };\n};\n\nexport default composeWithTracker(composer)(PostList);\n```\n\nIn addition to above, you can also return a cleanup function from the composer function. See the following example:\n\n```js\nimport {composeWithTracker} from 'react-komposer';\nimport PostList from '../components/post_list.jsx';\n\nconst composerFunction = (props, onData) => {\n  // tracker related code\n  return () => {console.log('Container disposed!');}\n};\n\n// Note the use of composeWithTracker\nconst Container = composeWithTracker(composerFunction)(PostList);\n```\n\nFor more information, refer this article: [Using Meteor Data and React with Meteor 1.3](https://voice.kadira.io/using-meteor-data-and-react-with-meteor-1-3-13cb0935dedb)\n\n\n### Using with Rx.js Observables\n\n```js\nimport {composeWithObservable} from 'react-komposer'\n\n// Create a component to display Time\nconst Time = ({time}) => (<div>{time}</div>);\n\nconst now = Rx.Observable.interval(1000)\n  .map(() => ({time: new Date().toString()}));\n\n// Create the composer function and tell how to fetch data\nconst composerFunction = (props) => now;\n\n// Compose the container\nconst Clock = composeWithObservable(composerFunction)(Time);\n\n// Render the container\nReactDOM.render(<Clock />, document.getElementById('react-root'));\n```\n\nTry this live: <https://jsfiddle.net/arunoda/Lsdekh4y/>\n\n### Using with Redux\n\n```js\n\nconst defaultState = {time: new Date().toString()};\nconst store = Redux.createStore((state = defaultState, action) => {\n  switch(action.type) {\n    case 'UPDATE_TIME':\n      return {\n        ...state,\n        time: action.time\n      };\n    default:\n      return state;\n  }\n});\n\nsetInterval(() => {\n  store.dispatch({\n    type: 'UPDATE_TIME',\n    time: new Date().toString()\n  });\n}, 1000);\n\n\nconst Time = ({time}) => (<div><b>Time is</b>: {time}</div>);\n\nconst onPropsChange = (props, onData) => {\n  onData(null, {time: store.getState().time});\n  return store.subscribe(() => {\n    const {time} = store.getState();\n    onData(null, {time})\n  });\n};\n\nconst Clock = compose(onPropsChange)(Time);\n\nReactDOM.render(<Clock />, document.getElementById('react'))\n```\n\nTry this live: <https://jsfiddle.net/arunoda/wm6romh4/>\n\n### Using with MobX\n\n```js\nconst store = mobx.observable({time: new Date().toString()});\n\nsetInterval(() => store.time = new Date().toString(), 1000);\n\nconst Time = ({time}) => (<div><b>Time is</b>: {time}</div>);\n\nonst onPropsChange = (props, onData) => {\n  const {time} = store;\n  onData(null, {time});\n};\n\nconst Clock = composeWithMobx(onPropsChange)(Time);\n\nReactDOM.render(<Clock />, document.getElementById('react'));\n```\n\n## Extending\n\nContainers built by React Komposer are still React components. This means that they can be extended in the same way\nyou would extend any other component. This is demonstrated in the following example:\n\n\n```js\nconst Tick = compose(onPropsChange)(Time);\nclass Clock extends Tick {\n  componentDidMount() {\n    console.log('Clock started');\n\n    return super();\n  }\n  componentWillUnmount() {\n    console.log('Clock stopped');\n\n    return super();\n  }\n};\nClock.displayName = 'ClockContainer';\n\nexport default Clock;\n```\n\nRemember to call `super` when overriding methods already defined in the Container.\n\n## Stubbing\n\nIt's very important to stub Containers used with `react-komposer` when we are doing isolated UI testing (especially with\n[react-storybook](https://github.com/kadirahq/react-storybook)). Here's how you can stub composers:\n\n**First of all, this only works if you are using the `composeAll` utility function.**\n\nAt the very beginning of your initial JS file, set the following code:\n\n```js\nimport { setStubbingMode } from 'react-komposer';\nsetStubbingMode(true);\n```\n\n> In react-storybook, that's in the `.storybook/config.js` file.\n\nThen all your containers will look like this:\n\n![With no stub](docs/with-no-stub.png)\n\nIf you need, you can set a stub composer and pass data to the original component, bypassing the actual composer function.\nYou can do this, before using the component which has the Container.\n\n```js\nimport { setComposerStub } from 'react-komposer';\nimport CommentList from '../comment_list';\nimport CreateComment from '../../containers/create_comment';\n\n// Create the stub for the composer.\nsetComposerStub(CreateComment, (props) => {\n  const data = {\n    ...props,\n    create: () => {},\n  };\n\n  return data;\n});\n```\n\n> In react-storybook, you can do this when you are writing stories.\n\nHere, the `CreateComment` container is being used inside the `CommentList` Container. We simply set a stubComposer,\nwhich returns some data. That data will be passed as props to the original UI Component, wrapped by the `CreateComment` Container.\n\nThis is how it looks after using the stub:\n\n![With stub](docs/with-stub.png)\n\nYou can see a real example in the [Mantra sample blog app](https://github.com/mantrajs/mantra-sample-blog-app).\n\n## Caveats\n\n**SSR**\n\nOn the server, we won't be able to cleanup resources even if you return the cleanup function. That's because there is no\nfunctionality to detect component unmount on the server. So make sure to handle the cleanup logic by yourself, in this case.\n\n**Composer re-run on any prop change**\n\nRight now, the composer function will run again for any prop change. We can fix this by watching props and deciding which\nprop has been changed. See [#4](https://github.com/kadirahq/react-komposer/issues/4).\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kadirahq/react-komposer.git"
  },
  "scripts": {
    "lint": "eslint ./lib",
    "lintfix": "eslint ./lib --fix",
    "prepublish": ". ./scripts/prepublish.sh",
    "test": "npm run lint && npm run testonly",
    "test-watch": "npm run testonly -- --watch",
    "testonly": "mocha $npm_package_options_mocha"
  },
  "version": "1.13.1"
}
